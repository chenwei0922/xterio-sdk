import{cS as L,cw as Re,aI as h,aM as O,df as ye,dg as we,aC as Ge}from"./index-Bn-ps2Oq.js";function Me(i,e){for(var o=0;o<e.length;o++){const t=e[o];if(typeof t!="string"&&!Array.isArray(t)){for(const s in t)if(s!=="default"&&!(s in i)){const n=Object.getOwnPropertyDescriptor(t,s);n&&Object.defineProperty(i,s,n.get?n:{enumerable:!0,get:()=>t[s]})}}}return Object.freeze(Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}))}var xe={},Y={},j={},_e={},ce={},Fe={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */(function(i){(function(e){e(typeof DO_NOT_EXPORT_CRC>"u"?i:{})})(function(e){e.version="1.2.2";function o(){for(var c=0,B=new Array(256),f=0;f!=256;++f)c=f,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,B[f]=c;return typeof Int32Array<"u"?new Int32Array(B):B}var t=o();function s(c){var B=0,f=0,v=0,k=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(v=0;v!=256;++v)k[v]=c[v];for(v=0;v!=256;++v)for(f=c[v],B=256+v;B<4096;B+=256)f=k[B]=f>>>8^c[f&255];var y=[];for(v=1;v!=16;++v)y[v-1]=typeof Int32Array<"u"?k.subarray(v*256,v*256+256):k.slice(v*256,v*256+256);return y}var n=s(t),a=n[0],r=n[1],d=n[2],m=n[3],u=n[4],l=n[5],E=n[6],w=n[7],T=n[8],C=n[9],_=n[10],K=n[11],F=n[12],I=n[13],H=n[14];function le(c,B){for(var f=B^-1,v=0,k=c.length;v<k;)f=f>>>8^t[(f^c.charCodeAt(v++))&255];return~f}function ee(c,B){for(var f=B^-1,v=c.length-15,k=0;k<v;)f=H[c[k++]^f&255]^I[c[k++]^f>>8&255]^F[c[k++]^f>>16&255]^K[c[k++]^f>>>24]^_[c[k++]]^C[c[k++]]^T[c[k++]]^w[c[k++]]^E[c[k++]]^l[c[k++]]^u[c[k++]]^m[c[k++]]^d[c[k++]]^r[c[k++]]^a[c[k++]]^t[c[k++]];for(v+=15;k<v;)f=f>>>8^t[(f^c[k++])&255];return~f}function De(c,B){for(var f=B^-1,v=0,k=c.length,y=0,ge=0;v<k;)y=c.charCodeAt(v++),y<128?f=f>>>8^t[(f^y)&255]:y<2048?(f=f>>>8^t[(f^(192|y>>6&31))&255],f=f>>>8^t[(f^(128|y&63))&255]):y>=55296&&y<57344?(y=(y&1023)+64,ge=c.charCodeAt(v++)&1023,f=f>>>8^t[(f^(240|y>>8&7))&255],f=f>>>8^t[(f^(128|y>>2&63))&255],f=f>>>8^t[(f^(128|ge>>6&15|(y&3)<<4))&255],f=f>>>8^t[(f^(128|ge&63))&255]):(f=f>>>8^t[(f^(224|y>>12&15))&255],f=f>>>8^t[(f^(128|y>>6&63))&255],f=f>>>8^t[(f^(128|y&63))&255]);return~f}e.table=t,e.bstr=le,e.buf=ee,e.str=De})})(Fe);const Ne="goerli",qe=5,ze=5,Ue="merge",je={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},Ke="Cross-client PoA test network",Ve="https://github.com/goerli/testnet",Je={timestamp:"0x5c51a607",gasLimit:10485760,difficulty:1,nonce:"0x0000000000000000",extraData:"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},Ye=[{name:"chainstart",block:0,forkHash:"0xa3f5ab08"},{name:"homestead",block:0,forkHash:"0xa3f5ab08"},{name:"tangerineWhistle",block:0,forkHash:"0xa3f5ab08"},{name:"spuriousDragon",block:0,forkHash:"0xa3f5ab08"},{name:"byzantium",block:0,forkHash:"0xa3f5ab08"},{name:"constantinople",block:0,forkHash:"0xa3f5ab08"},{name:"petersburg",block:0,forkHash:"0xa3f5ab08"},{name:"istanbul",block:1561651,forkHash:"0xc25efa5c"},{name:"berlin",block:4460644,forkHash:"0x757a1c47"},{name:"london",block:5062605,forkHash:"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",name:"merge",ttd:"10790000",block:7382819,forkHash:"0xb8c6299d"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1678832736",forkHash:"0xf9843abf"}],Xe=[{ip:"51.141.78.53",port:30303,id:"011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",location:"",comment:"Upstream bootnode 1"},{ip:"13.93.54.137",port:30303,id:"176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",location:"",comment:"Upstream bootnode 2"},{ip:"94.237.54.114",port:30313,id:"46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",location:"",comment:"Upstream bootnode 3"},{ip:"18.218.250.66",port:30313,id:"b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",location:"",comment:"Upstream bootnode 4"},{ip:"3.11.147.67",port:30303,id:"a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",location:"",comment:"Ethereum Foundation bootnode"},{ip:"51.15.116.226",port:30303,id:"a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:30303,id:"807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:40303,id:"a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",location:"",comment:"Goerli Initiative bootnode"}],We=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"],Ze={name:Ne,chainId:qe,networkId:ze,defaultHardfork:Ue,consensus:je,comment:Ke,url:Ve,genesis:Je,hardforks:Ye,bootstrapNodes:Xe,dnsNetworks:We},Qe="mainnet",et=1,tt=1,ot="merge",st={type:"pow",algorithm:"ethash",ethash:{}},nt="The Ethereum main chain",rt="https://ethstats.net/",at={gasLimit:5e3,difficulty:17179869184,nonce:"0x0000000000000042",extraData:"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},it=[{name:"chainstart",block:0,forkHash:"0xfc64ec04"},{name:"homestead",block:115e4,forkHash:"0x97c2c34c"},{name:"dao",block:192e4,forkHash:"0x91d1f948"},{name:"tangerineWhistle",block:2463e3,forkHash:"0x7a64da13"},{name:"spuriousDragon",block:2675e3,forkHash:"0x3edd5b10"},{name:"byzantium",block:437e4,forkHash:"0xa00bc324"},{name:"constantinople",block:728e4,forkHash:"0x668db0af"},{name:"petersburg",block:728e4,forkHash:"0x668db0af"},{name:"istanbul",block:9069e3,forkHash:"0x879d6e30"},{name:"muirGlacier",block:92e5,forkHash:"0xe029e991"},{name:"berlin",block:12244e3,forkHash:"0x0eb440f6"},{name:"london",block:12965e3,forkHash:"0xb715077d"},{name:"arrowGlacier",block:13773e3,forkHash:"0x20c327fc"},{name:"grayGlacier",block:1505e4,forkHash:"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",name:"merge",ttd:"58750000000000000000000",block:15537394,forkHash:"0xf0afd0e3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1681338455",forkHash:"0xdce96c2d"}],ct=[{ip:"18.138.108.67",port:30303,id:"d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",location:"ap-southeast-1-001",comment:"bootnode-aws-ap-southeast-1-001"},{ip:"3.209.45.79",port:30303,id:"22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",location:"us-east-1-001",comment:"bootnode-aws-us-east-1-001"},{ip:"65.108.70.101",port:30303,id:"2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",location:"eu-west-1-001",comment:"bootnode-hetzner-hel"},{ip:"157.90.35.166",port:30303,id:"4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",location:"eu-central-1-001",comment:"bootnode-hetzner-fsn"}],dt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"],ft={name:Qe,chainId:et,networkId:tt,defaultHardfork:ot,consensus:st,comment:nt,url:rt,genesis:at,hardforks:it,bootstrapNodes:ct,dnsNetworks:dt},ut="rinkeby",mt=4,ht=4,lt="london",gt={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},pt="PoA test network",bt="https://www.rinkeby.io",vt={timestamp:"0x58ee40ba",gasLimit:47e5,difficulty:1,nonce:"0x0000000000000000",extraData:"0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},$t=[{name:"chainstart",block:0,forkHash:"0x3b8e0691"},{name:"homestead",block:1,forkHash:"0x60949295"},{name:"tangerineWhistle",block:2,forkHash:"0x8bde40dd"},{name:"spuriousDragon",block:3,forkHash:"0xcb3a64bb"},{name:"byzantium",block:1035301,forkHash:"0x8d748b57"},{name:"constantinople",block:3660663,forkHash:"0xe49cab14"},{name:"petersburg",block:4321234,forkHash:"0xafec6b27"},{name:"istanbul",block:5435345,forkHash:"0xcbdb8838"},{name:"berlin",block:8290928,forkHash:"0x6910c8bd"},{name:"london",block:8897988,forkHash:"0x8e29f2f3"},{name:"merge",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],kt=[{ip:"52.169.42.101",port:30303,id:"a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",location:"",comment:"IE"},{ip:"52.3.158.184",port:30303,id:"343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",location:"",comment:"INFURA"},{ip:"159.89.28.211",port:30303,id:"b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",location:"",comment:"AKASHA"}],It=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"],Pt={name:ut,chainId:mt,networkId:ht,defaultHardfork:lt,consensus:gt,comment:pt,url:bt,genesis:vt,hardforks:$t,bootstrapNodes:kt,dnsNetworks:It},Et="ropsten",Tt=3,yt=3,wt="merge",xt={type:"pow",algorithm:"ethash",ethash:{}},Bt="PoW test network",St="https://github.com/ethereum/ropsten",At={gasLimit:16777216,difficulty:1048576,nonce:"0x0000000000000042",extraData:"0x3535353535353535353535353535353535353535353535353535353535353535"},Ht=[{name:"chainstart",block:0,forkHash:"0x30c7ddbc"},{name:"homestead",block:0,forkHash:"0x30c7ddbc"},{name:"tangerineWhistle",block:0,forkHash:"0x30c7ddbc"},{name:"spuriousDragon",block:10,forkHash:"0x63760190"},{name:"byzantium",block:17e5,forkHash:"0x3ea159c7"},{name:"constantinople",block:423e4,forkHash:"0x97b544f3"},{name:"petersburg",block:4939394,forkHash:"0xd6e2149b"},{name:"istanbul",block:6485846,forkHash:"0x4bc66396"},{name:"muirGlacier",block:7117117,forkHash:"0x6727ef90"},{name:"berlin",block:9812189,forkHash:"0xa157d377"},{name:"london",block:10499401,forkHash:"0x7119b6b3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge",name:"merge",ttd:"50000000000000000",block:null,forkHash:"0x7119b6b3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],Ct=[{ip:"52.176.7.10",port:30303,id:"30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",location:"",comment:"US-Azure geth"},{ip:"52.176.100.77",port:30303,id:"865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",location:"",comment:"US-Azure parity"},{ip:"52.232.243.152",port:30303,id:"6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",location:"",comment:"Parity"},{ip:"192.81.208.223",port:30303,id:"94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",location:"",comment:"@gpip"}],Lt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"],_t={name:Et,chainId:Tt,networkId:yt,defaultHardfork:wt,consensus:xt,comment:Bt,url:St,genesis:At,hardforks:Ht,bootstrapNodes:Ct,dnsNetworks:Lt},Ft="sepolia",Ot=11155111,Dt=11155111,Rt="merge",Gt={type:"pow",algorithm:"ethash",ethash:{}},Mt="PoW test network to replace Ropsten",Nt="https://github.com/ethereum/go-ethereum/pull/23730",qt={timestamp:"0x6159af19",gasLimit:3e7,difficulty:131072,nonce:"0x0000000000000000",extraData:"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},zt=[{name:"chainstart",block:0,forkHash:"0xfe3366e7"},{name:"homestead",block:0,forkHash:"0xfe3366e7"},{name:"tangerineWhistle",block:0,forkHash:"0xfe3366e7"},{name:"spuriousDragon",block:0,forkHash:"0xfe3366e7"},{name:"byzantium",block:0,forkHash:"0xfe3366e7"},{name:"constantinople",block:0,forkHash:"0xfe3366e7"},{name:"petersburg",block:0,forkHash:"0xfe3366e7"},{name:"istanbul",block:0,forkHash:"0xfe3366e7"},{name:"muirGlacier",block:0,forkHash:"0xfe3366e7"},{name:"berlin",block:0,forkHash:"0xfe3366e7"},{name:"london",block:0,forkHash:"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",name:"merge",ttd:"17000000000000000",block:1450409,forkHash:"0xfe3366e7"},{name:"mergeForkIdTransition",block:1735371,forkHash:"0xb96cbd13"},{name:"shanghai",block:null,timestamp:"1677557088",forkHash:"0xf7f9bc08"}],Ut=[{ip:"18.168.182.86",port:30303,id:"9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",location:"",comment:"geth"},{ip:"52.14.151.177",port:30303,id:"ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",location:"",comment:"besu"},{ip:"165.22.196.173",port:30303,id:"ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",location:"",comment:"EF"},{ip:"65.108.95.67",port:30303,id:"075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",location:"",comment:"lodestar"}],jt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"],Kt={name:Ft,chainId:Ot,networkId:Dt,defaultHardfork:Rt,consensus:Gt,comment:Mt,url:Nt,genesis:qt,hardforks:zt,bootstrapNodes:Ut,dnsNetworks:jt};var de={};const Vt="EIP-1153",Jt=1153,Yt="Transient Storage",Xt="https://eips.ethereum.org/EIPS/eip-1153",Wt="Review",Zt="chainstart",Qt=[],eo={},to={tstore:{v:100,d:"Base fee of the TSTORE opcode"},tload:{v:100,d:"Base fee of the TLOAD opcode"}},oo={},so={},no={name:Vt,number:Jt,comment:Yt,url:Xt,status:Wt,minimumHardfork:Zt,requiredEIPs:Qt,gasConfig:eo,gasPrices:to,vm:oo,pow:so},ro="EIP-1559",ao=1559,io="Fee market change for ETH 1.0 chain",co="https://eips.ethereum.org/EIPS/eip-1559",fo="Final",uo="berlin",mo=[2930],ho={baseFeeMaxChangeDenominator:{v:8,d:"Maximum base fee change denominator"},elasticityMultiplier:{v:2,d:"Maximum block gas target elasticity"},initialBaseFee:{v:1e9,d:"Initial base fee on first EIP1559 block"}},lo={},go={},po={},bo={name:ro,number:ao,comment:io,url:co,status:fo,minimumHardfork:uo,requiredEIPs:mo,gasConfig:ho,gasPrices:lo,vm:go,pow:po},vo="EIP-2315",$o=2315,ko="Simple subroutines for the EVM",Io="https://eips.ethereum.org/EIPS/eip-2315",Po="Draft",Eo="istanbul",To={},yo={beginsub:{v:2,d:"Base fee of the BEGINSUB opcode"},returnsub:{v:5,d:"Base fee of the RETURNSUB opcode"},jumpsub:{v:10,d:"Base fee of the JUMPSUB opcode"}},wo={},xo={},Bo={name:vo,number:$o,comment:ko,url:Io,status:Po,minimumHardfork:Eo,gasConfig:To,gasPrices:yo,vm:wo,pow:xo},So="EIP-2537",Ao=2537,Ho="BLS12-381 precompiles",Co="https://eips.ethereum.org/EIPS/eip-2537",Lo="Draft",_o="chainstart",Fo={},Oo={Bls12381G1AddGas:{v:600,d:"Gas cost of a single BLS12-381 G1 addition precompile-call"},Bls12381G1MulGas:{v:12e3,d:"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},Bls12381G2AddGas:{v:4500,d:"Gas cost of a single BLS12-381 G2 addition precompile-call"},Bls12381G2MulGas:{v:55e3,d:"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},Bls12381PairingBaseGas:{v:115e3,d:"Base gas cost of BLS12-381 pairing check"},Bls12381PairingPerPairGas:{v:23e3,d:"Per-pair gas cost of BLS12-381 pairing check"},Bls12381MapG1Gas:{v:5500,d:"Gas cost of BLS12-381 map field element to G1"},Bls12381MapG2Gas:{v:11e4,d:"Gas cost of BLS12-381 map field element to G2"},Bls12381MultiExpGasDiscount:{v:[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],d:"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},Do={},Ro={},Go={name:So,number:Ao,comment:Ho,url:Co,status:Lo,minimumHardfork:_o,gasConfig:Fo,gasPrices:Oo,vm:Do,pow:Ro},Mo="EIP-2565",No=2565,qo="ModExp gas cost",zo="https://eips.ethereum.org/EIPS/eip-2565",Uo="Final",jo="byzantium",Ko={},Vo={modexpGquaddivisor:{v:3,d:"Gquaddivisor from modexp precompile for gas calculation"}},Jo={},Yo={},Xo={name:Mo,number:No,comment:qo,url:zo,status:Uo,minimumHardfork:jo,gasConfig:Ko,gasPrices:Vo,vm:Jo,pow:Yo},Wo="EIP-2718",Zo="Typed Transaction Envelope",Qo="https://eips.ethereum.org/EIPS/eip-2718",es="Final",ts="chainstart",os={},ss={},ns={},rs={},as={name:Wo,comment:Zo,url:Qo,status:es,minimumHardfork:ts,gasConfig:os,gasPrices:ss,vm:ns,pow:rs},is="EIP-2929",cs="Gas cost increases for state access opcodes",ds="https://eips.ethereum.org/EIPS/eip-2929",fs="Final",us="chainstart",ms={},hs={coldsload:{v:2100,d:"Gas cost of the first read of storage from a given location (per transaction)"},coldaccountaccess:{v:2600,d:"Gas cost of the first read of a given address (per transaction)"},warmstorageread:{v:100,d:"Gas cost of reading storage locations which have already loaded 'cold'"},sstoreCleanGasEIP2200:{v:2900,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreNoopGasEIP2200:{v:100,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:100,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitRefundEIP2200:{v:19900,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanRefundEIP2200:{v:4900,d:"Once per SSTORE operation for resetting to the original non-zero value"},call:{v:0,d:"Base fee of the CALL opcode"},callcode:{v:0,d:"Base fee of the CALLCODE opcode"},delegatecall:{v:0,d:"Base fee of the DELEGATECALL opcode"},staticcall:{v:0,d:"Base fee of the STATICCALL opcode"},balance:{v:0,d:"Base fee of the BALANCE opcode"},extcodesize:{v:0,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:0,d:"Base fee of the EXTCODECOPY opcode"},extcodehash:{v:0,d:"Base fee of the EXTCODEHASH opcode"},sload:{v:0,d:"Base fee of the SLOAD opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"}},ls={},gs={},ps={name:is,comment:cs,url:ds,status:fs,minimumHardfork:us,gasConfig:ms,gasPrices:hs,vm:ls,pow:gs},bs="EIP-2930",vs="Optional access lists",$s="https://eips.ethereum.org/EIPS/eip-2930",ks="Final",Is="istanbul",Ps=[2718,2929],Es={},Ts={accessListStorageKeyCost:{v:1900,d:"Gas cost per storage key in an Access List transaction"},accessListAddressCost:{v:2400,d:"Gas cost per storage key in an Access List transaction"}},ys={},ws={},xs={name:bs,comment:vs,url:$s,status:ks,minimumHardfork:Is,requiredEIPs:Ps,gasConfig:Es,gasPrices:Ts,vm:ys,pow:ws},Bs="EIP-3074",Ss=3074,As="AUTH and AUTHCALL opcodes",Hs="https://eips.ethereum.org/EIPS/eip-3074",Cs="Review",Ls="london",_s={},Fs={auth:{v:3100,d:"Gas cost of the AUTH opcode"},authcall:{v:0,d:"Gas cost of the AUTHCALL opcode"},authcallValueTransfer:{v:6700,d:"Paid for CALL when the value transfer is non-zero"}},Os={},Ds={},Rs={name:Bs,number:Ss,comment:As,url:Hs,status:Cs,minimumHardfork:Ls,gasConfig:_s,gasPrices:Fs,vm:Os,pow:Ds},Gs="EIP-3198",Ms=3198,Ns="BASEFEE opcode",qs="https://eips.ethereum.org/EIPS/eip-3198",zs="Final",Us="london",js={},Ks={basefee:{v:2,d:"Gas cost of the BASEFEE opcode"}},Vs={},Js={},Ys={name:Gs,number:Ms,comment:Ns,url:qs,status:zs,minimumHardfork:Us,gasConfig:js,gasPrices:Ks,vm:Vs,pow:Js},Xs="EIP-3529",Ws="Reduction in refunds",Zs="https://eips.ethereum.org/EIPS/eip-3529",Qs="Final",en="berlin",tn=[2929],on={maxRefundQuotient:{v:5,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},sn={selfdestructRefund:{v:0,d:"Refunded following a selfdestruct operation"},sstoreClearRefundEIP2200:{v:4800,d:"Once per SSTORE operation for clearing an originally existing storage slot"}},nn={},rn={},an={name:Xs,comment:Ws,url:Zs,status:Qs,minimumHardfork:en,requiredEIPs:tn,gasConfig:on,gasPrices:sn,vm:nn,pow:rn},cn="EIP-3540",dn=3540,fn="EVM Object Format (EOF) v1",un="https://eips.ethereum.org/EIPS/eip-3540",mn="Review",hn="london",ln=[3541],gn={},pn={},bn={},vn={},$n={name:cn,number:dn,comment:fn,url:un,status:mn,minimumHardfork:hn,requiredEIPs:ln,gasConfig:gn,gasPrices:pn,vm:bn,pow:vn},kn="EIP-3541",In="Reject new contracts starting with the 0xEF byte",Pn="https://eips.ethereum.org/EIPS/eip-3541",En="Final",Tn="berlin",yn=[],wn={},xn={},Bn={},Sn={},An={name:kn,comment:In,url:Pn,status:En,minimumHardfork:Tn,requiredEIPs:yn,gasConfig:wn,gasPrices:xn,vm:Bn,pow:Sn},Hn="EIP-3554",Cn="Reduction in refunds",Ln="Difficulty Bomb Delay to December 1st 2021",_n="Final",Fn="muirGlacier",On=[],Dn={},Rn={},Gn={},Mn={difficultyBombDelay:{v:95e5,d:"the amount of blocks to delay the difficulty bomb with"}},Nn={name:Hn,comment:Cn,url:Ln,status:_n,minimumHardfork:Fn,requiredEIPs:On,gasConfig:Dn,gasPrices:Rn,vm:Gn,pow:Mn},qn="EIP-3607",zn=3607,Un="Reject transactions from senders with deployed code",jn="https://eips.ethereum.org/EIPS/eip-3607",Kn="Final",Vn="chainstart",Jn=[],Yn={},Xn={},Wn={},Zn={},Qn={name:qn,number:zn,comment:Un,url:jn,status:Kn,minimumHardfork:Vn,requiredEIPs:Jn,gasConfig:Yn,gasPrices:Xn,vm:Wn,pow:Zn},er="EIP-3651",tr=3198,or="Warm COINBASE",sr="https://eips.ethereum.org/EIPS/eip-3651",nr="Review",rr="london",ar=[2929],ir={},cr={},dr={},fr={},ur={name:er,number:tr,comment:or,url:sr,status:nr,minimumHardfork:rr,requiredEIPs:ar,gasConfig:ir,gasPrices:cr,vm:dr,pow:fr},mr="EIP-3670",hr=3670,lr="EOF - Code Validation",gr="https://eips.ethereum.org/EIPS/eip-3670",pr="Review",br="london",vr=[3540],$r={},kr={},Ir={},Pr={},Er={name:mr,number:hr,comment:lr,url:gr,status:pr,minimumHardfork:br,requiredEIPs:vr,gasConfig:$r,gasPrices:kr,vm:Ir,pow:Pr},Tr="EIP-3675",yr=3675,wr="Upgrade consensus to Proof-of-Stake",xr="https://eips.ethereum.org/EIPS/eip-3675",Br="Final",Sr="london",Ar=[],Hr={},Cr={},Lr={},_r={},Fr={name:Tr,number:yr,comment:wr,url:xr,status:Br,minimumHardfork:Sr,requiredEIPs:Ar,gasConfig:Hr,gasPrices:Cr,vm:Lr,pow:_r},Or="EIP-3855",Dr=3855,Rr="PUSH0 instruction",Gr="https://eips.ethereum.org/EIPS/eip-3855",Mr="Review",Nr="chainstart",qr=[],zr={},Ur={push0:{v:2,d:"Base fee of the PUSH0 opcode"}},jr={},Kr={},Vr={name:Or,number:Dr,comment:Rr,url:Gr,status:Mr,minimumHardfork:Nr,requiredEIPs:qr,gasConfig:zr,gasPrices:Ur,vm:jr,pow:Kr},Jr="EIP-3860",Yr=3860,Xr="Limit and meter initcode",Wr="https://eips.ethereum.org/EIPS/eip-3860",Zr="Review",Qr="spuriousDragon",ea=[],ta={},oa={initCodeWordCost:{v:2,d:"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},sa={maxInitCodeSize:{v:49152,d:"Maximum length of initialization code when creating a contract"}},na={},ra={name:Jr,number:Yr,comment:Xr,url:Wr,status:Zr,minimumHardfork:Qr,requiredEIPs:ea,gasConfig:ta,gasPrices:oa,vm:sa,pow:na},aa="EIP-4345",ia=4345,ca="Difficulty Bomb Delay to June 2022",da="https://eips.ethereum.org/EIPS/eip-4345",fa="Final",ua="london",ma={},ha={},la={},ga={difficultyBombDelay:{v:107e5,d:"the amount of blocks to delay the difficulty bomb with"}},pa={name:aa,number:ia,comment:ca,url:da,status:fa,minimumHardfork:ua,gasConfig:ma,gasPrices:ha,vm:la,pow:ga},ba="EIP-4399",va=4399,$a="Supplant DIFFICULTY opcode with PREVRANDAO",ka="https://eips.ethereum.org/EIPS/eip-4399",Ia="Review",Pa="london",Ea=[],Ta={},ya={},wa={},xa={},Ba={name:ba,number:va,comment:$a,url:ka,status:Ia,minimumHardfork:Pa,requiredEIPs:Ea,gasConfig:Ta,gasPrices:ya,vm:wa,pow:xa},Sa="EIP-4844",Aa=4844,Ha="Shard Blob Transactions",Ca="https://eips.ethereum.org/EIPS/eip-4844",La="Draft",_a="merge",Fa=[1559,2718,2930,4895],Oa={dataGasPerBlob:{v:131072,d:"The base fee for data gas per blob"},targetDataGasPerBlock:{v:262144,d:"The target data gas consumed per block"},maxDataGasPerBlock:{v:524288,d:"The max data gas allowable per block"},dataGasPriceUpdateFraction:{v:2225652,d:"The denominator used in the exponential when calculating a data gas price"}},Da={simpleGasPerBlob:{v:12e3,d:"The basic gas fee for each blob"},minDataGasPrice:{v:1,d:"The minimum fee per data gas"},kzgPointEvaluationGasPrecompilePrice:{v:5e4,d:"The fee associated with the point evaluation precompile"},datahash:{v:3,d:"Base fee of the DATAHASH opcode"}},Ra={blobCommitmentVersionKzg:{v:1,d:"The number indicated a versioned hash is a KZG commitment"},fieldElementsPerBlob:{v:4096,d:"The number of field elements allowed per blob"}},Ga={},Ma={},Na={name:Sa,number:Aa,comment:Ha,url:Ca,status:La,minimumHardfork:_a,requiredEIPs:Fa,gasConfig:Oa,gasPrices:Da,sharding:Ra,vm:Ga,pow:Ma},qa="EIP-4895",za=4895,Ua="Beacon chain push withdrawals as operations",ja="https://eips.ethereum.org/EIPS/eip-4895",Ka="Review",Va="merge",Ja=[],Ya={},Xa={},Wa={},Za={},Qa={name:qa,number:za,comment:Ua,url:ja,status:Ka,minimumHardfork:Va,requiredEIPs:Ja,gasConfig:Ya,gasPrices:Xa,vm:Wa,pow:Za},ei="EIP-5133",ti=5133,oi="Delaying Difficulty Bomb to mid-September 2022",si="https://eips.ethereum.org/EIPS/eip-5133",ni="Draft",ri="grayGlacier",ai={},ii={},ci={},di={difficultyBombDelay:{v:114e5,d:"the amount of blocks to delay the difficulty bomb with"}},fi={name:ei,number:ti,comment:oi,url:si,status:ni,minimumHardfork:ri,gasConfig:ai,gasPrices:ii,vm:ci,pow:di};Object.defineProperty(de,"__esModule",{value:!0});de.EIPs=void 0;de.EIPs={1153:no,1559:bo,2315:Bo,2537:Go,2565:Xo,2718:as,2929:ps,2930:xs,3074:Rs,3198:Ys,3529:an,3540:$n,3541:An,3554:Nn,3607:Qn,3651:ur,3670:Er,3675:Fr,3855:Vr,3860:ra,4345:pa,4399:Ba,4844:Na,4895:Qa,5133:fi};var fe={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.CustomChain=i.ConsensusAlgorithm=i.ConsensusType=i.Hardfork=i.Chain=void 0,function(e){e[e.Mainnet=1]="Mainnet",e[e.Ropsten=3]="Ropsten",e[e.Rinkeby=4]="Rinkeby",e[e.Goerli=5]="Goerli",e[e.Sepolia=11155111]="Sepolia"}(i.Chain||(i.Chain={})),function(e){e.Chainstart="chainstart",e.Homestead="homestead",e.Dao="dao",e.TangerineWhistle="tangerineWhistle",e.SpuriousDragon="spuriousDragon",e.Byzantium="byzantium",e.Constantinople="constantinople",e.Petersburg="petersburg",e.Istanbul="istanbul",e.MuirGlacier="muirGlacier",e.Berlin="berlin",e.London="london",e.ArrowGlacier="arrowGlacier",e.GrayGlacier="grayGlacier",e.MergeForkIdTransition="mergeForkIdTransition",e.Merge="merge",e.Shanghai="shanghai",e.ShardingForkDev="shardingFork"}(i.Hardfork||(i.Hardfork={})),function(e){e.ProofOfStake="pos",e.ProofOfWork="pow",e.ProofOfAuthority="poa"}(i.ConsensusType||(i.ConsensusType={})),function(e){e.Ethash="ethash",e.Clique="clique",e.Casper="casper"}(i.ConsensusAlgorithm||(i.ConsensusAlgorithm={})),function(e){e.PolygonMainnet="polygon-mainnet",e.PolygonMumbai="polygon-mumbai",e.ArbitrumRinkebyTestnet="arbitrum-rinkeby-testnet",e.ArbitrumOne="arbitrum-one",e.xDaiChain="x-dai-chain",e.OptimisticKovan="optimistic-kovan",e.OptimisticEthereum="optimistic-ethereum"}(i.CustomChain||(i.CustomChain={}))})(fe);var ue={};const ui="chainstart",mi="Start of the Ethereum main chain",hi="",li="",gi={minGasLimit:{v:5e3,d:"Minimum the gas limit may ever be"},gasLimitBoundDivisor:{v:1024,d:"The bound divisor of the gas limit, used in update calculations"},maxRefundQuotient:{v:2,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},pi={base:{v:2,d:"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},tierStep:{v:[0,2,3,5,8,10,20],d:"Once per operation, for a selection of them"},exp:{v:10,d:"Base fee of the EXP opcode"},expByte:{v:10,d:"Times ceil(log256(exponent)) for the EXP instruction"},sha3:{v:30,d:"Base fee of the SHA3 opcode"},sha3Word:{v:6,d:"Once per word of the SHA3 operation's data"},sload:{v:50,d:"Base fee of the SLOAD opcode"},sstoreSet:{v:2e4,d:"Once per SSTORE operation if the zeroness changes from zero"},sstoreReset:{v:5e3,d:"Once per SSTORE operation if the zeroness does not change from zero"},sstoreRefund:{v:15e3,d:"Once per SSTORE operation if the zeroness changes to zero"},jumpdest:{v:1,d:"Base fee of the JUMPDEST opcode"},log:{v:375,d:"Base fee of the LOG opcode"},logData:{v:8,d:"Per byte in a LOG* operation's data"},logTopic:{v:375,d:"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},create:{v:32e3,d:"Base fee of the CREATE opcode"},call:{v:40,d:"Base fee of the CALL opcode"},callStipend:{v:2300,d:"Free gas given at beginning of call"},callValueTransfer:{v:9e3,d:"Paid for CALL when the value transfor is non-zero"},callNewAccount:{v:25e3,d:"Paid for CALL when the destination address didn't exist prior"},selfdestructRefund:{v:24e3,d:"Refunded following a selfdestruct operation"},memory:{v:3,d:"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},quadCoeffDiv:{v:512,d:"Divisor for the quadratic particle of the memory cost equation"},createData:{v:200,d:""},tx:{v:21e3,d:"Per transaction. NOTE: Not payable on data of calls between transactions"},txCreation:{v:32e3,d:"The cost of creating a contract via tx"},txDataZero:{v:4,d:"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},txDataNonZero:{v:68,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},copy:{v:3,d:"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},ecRecover:{v:3e3,d:""},sha256:{v:60,d:""},sha256Word:{v:12,d:""},ripemd160:{v:600,d:""},ripemd160Word:{v:120,d:""},identity:{v:15,d:""},identityWord:{v:3,d:""},stop:{v:0,d:"Base fee of the STOP opcode"},add:{v:3,d:"Base fee of the ADD opcode"},mul:{v:5,d:"Base fee of the MUL opcode"},sub:{v:3,d:"Base fee of the SUB opcode"},div:{v:5,d:"Base fee of the DIV opcode"},sdiv:{v:5,d:"Base fee of the SDIV opcode"},mod:{v:5,d:"Base fee of the MOD opcode"},smod:{v:5,d:"Base fee of the SMOD opcode"},addmod:{v:8,d:"Base fee of the ADDMOD opcode"},mulmod:{v:8,d:"Base fee of the MULMOD opcode"},signextend:{v:5,d:"Base fee of the SIGNEXTEND opcode"},lt:{v:3,d:"Base fee of the LT opcode"},gt:{v:3,d:"Base fee of the GT opcode"},slt:{v:3,d:"Base fee of the SLT opcode"},sgt:{v:3,d:"Base fee of the SGT opcode"},eq:{v:3,d:"Base fee of the EQ opcode"},iszero:{v:3,d:"Base fee of the ISZERO opcode"},and:{v:3,d:"Base fee of the AND opcode"},or:{v:3,d:"Base fee of the OR opcode"},xor:{v:3,d:"Base fee of the XOR opcode"},not:{v:3,d:"Base fee of the NOT opcode"},byte:{v:3,d:"Base fee of the BYTE opcode"},address:{v:2,d:"Base fee of the ADDRESS opcode"},balance:{v:20,d:"Base fee of the BALANCE opcode"},origin:{v:2,d:"Base fee of the ORIGIN opcode"},caller:{v:2,d:"Base fee of the CALLER opcode"},callvalue:{v:2,d:"Base fee of the CALLVALUE opcode"},calldataload:{v:3,d:"Base fee of the CALLDATALOAD opcode"},calldatasize:{v:2,d:"Base fee of the CALLDATASIZE opcode"},calldatacopy:{v:3,d:"Base fee of the CALLDATACOPY opcode"},codesize:{v:2,d:"Base fee of the CODESIZE opcode"},codecopy:{v:3,d:"Base fee of the CODECOPY opcode"},gasprice:{v:2,d:"Base fee of the GASPRICE opcode"},extcodesize:{v:20,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:20,d:"Base fee of the EXTCODECOPY opcode"},blockhash:{v:20,d:"Base fee of the BLOCKHASH opcode"},coinbase:{v:2,d:"Base fee of the COINBASE opcode"},timestamp:{v:2,d:"Base fee of the TIMESTAMP opcode"},number:{v:2,d:"Base fee of the NUMBER opcode"},difficulty:{v:2,d:"Base fee of the DIFFICULTY opcode"},gaslimit:{v:2,d:"Base fee of the GASLIMIT opcode"},pop:{v:2,d:"Base fee of the POP opcode"},mload:{v:3,d:"Base fee of the MLOAD opcode"},mstore:{v:3,d:"Base fee of the MSTORE opcode"},mstore8:{v:3,d:"Base fee of the MSTORE8 opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"},jump:{v:8,d:"Base fee of the JUMP opcode"},jumpi:{v:10,d:"Base fee of the JUMPI opcode"},pc:{v:2,d:"Base fee of the PC opcode"},msize:{v:2,d:"Base fee of the MSIZE opcode"},gas:{v:2,d:"Base fee of the GAS opcode"},push:{v:3,d:"Base fee of the PUSH opcode"},dup:{v:3,d:"Base fee of the DUP opcode"},swap:{v:3,d:"Base fee of the SWAP opcode"},callcode:{v:40,d:"Base fee of the CALLCODE opcode"},return:{v:0,d:"Base fee of the RETURN opcode"},invalid:{v:0,d:"Base fee of the INVALID opcode"},selfdestruct:{v:0,d:"Base fee of the SELFDESTRUCT opcode"}},bi={stackLimit:{v:1024,d:"Maximum size of VM stack allowed"},callCreateDepth:{v:1024,d:"Maximum depth of call/create stack"},maxExtraDataSize:{v:32,d:"Maximum size extra data may be after Genesis"}},vi={minimumDifficulty:{v:131072,d:"The minimum that the difficulty may ever be"},difficultyBoundDivisor:{v:2048,d:"The bound divisor of the difficulty, used in the update calculations"},durationLimit:{v:13,d:"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},epochDuration:{v:3e4,d:"Duration between proof-of-work epochs"},timebombPeriod:{v:1e5,d:"Exponential difficulty timebomb period"},minerReward:{v:"5000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:0,d:"the amount of blocks to delay the difficulty bomb with"}},$i={name:ui,comment:mi,url:hi,status:li,gasConfig:gi,gasPrices:pi,vm:bi,pow:vi},ki="homestead",Ii="Homestead hardfork with protocol and network changes",Pi="https://eips.ethereum.org/EIPS/eip-606",Ei="Final",Ti={},yi={delegatecall:{v:40,d:"Base fee of the DELEGATECALL opcode"}},wi={},xi={},Bi={name:ki,comment:Ii,url:Pi,status:Ei,gasConfig:Ti,gasPrices:yi,vm:wi,pow:xi},Si="dao",Ai="DAO rescue hardfork",Hi="https://eips.ethereum.org/EIPS/eip-779",Ci="Final",Li={},_i={},Fi={},Oi={},Di={name:Si,comment:Ai,url:Hi,status:Ci,gasConfig:Li,gasPrices:_i,vm:Fi,pow:Oi},Ri="tangerineWhistle",Gi="Hardfork with gas cost changes for IO-heavy operations",Mi="https://eips.ethereum.org/EIPS/eip-608",Ni="Final",qi={},zi={sload:{v:200,d:"Once per SLOAD operation"},call:{v:700,d:"Once per CALL operation & message call transaction"},extcodesize:{v:700,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:700,d:"Base fee of the EXTCODECOPY opcode"},balance:{v:400,d:"Base fee of the BALANCE opcode"},delegatecall:{v:700,d:"Base fee of the DELEGATECALL opcode"},callcode:{v:700,d:"Base fee of the CALLCODE opcode"},selfdestruct:{v:5e3,d:"Base fee of the SELFDESTRUCT opcode"}},Ui={},ji={},Ki={name:Ri,comment:Gi,url:Mi,status:Ni,gasConfig:qi,gasPrices:zi,vm:Ui,pow:ji},Vi="spuriousDragon",Ji="HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",Yi="https://eips.ethereum.org/EIPS/eip-607",Xi="Final",Wi={},Zi={expByte:{v:50,d:"Times ceil(log256(exponent)) for the EXP instruction"}},Qi={maxCodeSize:{v:24576,d:"Maximum length of contract code"}},ec={},tc={name:Vi,comment:Ji,url:Yi,status:Xi,gasConfig:Wi,gasPrices:Zi,vm:Qi,pow:ec},oc="byzantium",sc="Hardfork with new precompiles, instructions and other protocol changes",nc="https://eips.ethereum.org/EIPS/eip-609",rc="Final",ac={},ic={modexpGquaddivisor:{v:20,d:"Gquaddivisor from modexp precompile for gas calculation"},ecAdd:{v:500,d:"Gas costs for curve addition precompile"},ecMul:{v:4e4,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:1e5,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:8e4,d:"Gas costs regarding curve pairing precompile input length"},revert:{v:0,d:"Base fee of the REVERT opcode"},staticcall:{v:700,d:"Base fee of the STATICCALL opcode"},returndatasize:{v:2,d:"Base fee of the RETURNDATASIZE opcode"},returndatacopy:{v:3,d:"Base fee of the RETURNDATACOPY opcode"}},cc={},dc={minerReward:{v:"3000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:3e6,d:"the amount of blocks to delay the difficulty bomb with"}},fc={name:oc,comment:sc,url:nc,status:rc,gasConfig:ac,gasPrices:ic,vm:cc,pow:dc},uc="constantinople",mc="Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",hc="https://eips.ethereum.org/EIPS/eip-1013",lc="Final",gc={},pc={netSstoreNoopGas:{v:200,d:"Once per SSTORE operation if the value doesn't change"},netSstoreInitGas:{v:2e4,d:"Once per SSTORE operation from clean zero"},netSstoreCleanGas:{v:5e3,d:"Once per SSTORE operation from clean non-zero"},netSstoreDirtyGas:{v:200,d:"Once per SSTORE operation from dirty"},netSstoreClearRefund:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},netSstoreResetRefund:{v:4800,d:"Once per SSTORE operation for resetting to the original non-zero value"},netSstoreResetClearRefund:{v:19800,d:"Once per SSTORE operation for resetting to the original zero value"},shl:{v:3,d:"Base fee of the SHL opcode"},shr:{v:3,d:"Base fee of the SHR opcode"},sar:{v:3,d:"Base fee of the SAR opcode"},extcodehash:{v:400,d:"Base fee of the EXTCODEHASH opcode"},create2:{v:32e3,d:"Base fee of the CREATE2 opcode"}},bc={},vc={minerReward:{v:"2000000000000000000",d:"The amount a miner gets rewarded for mining a block"},difficultyBombDelay:{v:5e6,d:"the amount of blocks to delay the difficulty bomb with"}},$c={name:uc,comment:mc,url:hc,status:lc,gasConfig:gc,gasPrices:pc,vm:bc,pow:vc},kc="petersburg",Ic="Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",Pc="https://eips.ethereum.org/EIPS/eip-1716",Ec="Final",Tc={},yc={netSstoreNoopGas:{v:null,d:"Removed along EIP-1283"},netSstoreInitGas:{v:null,d:"Removed along EIP-1283"},netSstoreCleanGas:{v:null,d:"Removed along EIP-1283"},netSstoreDirtyGas:{v:null,d:"Removed along EIP-1283"},netSstoreClearRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetClearRefund:{v:null,d:"Removed along EIP-1283"}},wc={},xc={},Bc={name:kc,comment:Ic,url:Pc,status:Ec,gasConfig:Tc,gasPrices:yc,vm:wc,pow:xc},Sc="istanbul",Ac="HF targeted for December 2019 following the Constantinople/Petersburg HF",Hc="https://eips.ethereum.org/EIPS/eip-1679",Cc="Final",Lc={},_c={blake2Round:{v:1,d:"Gas cost per round for the Blake2 F precompile"},ecAdd:{v:150,d:"Gas costs for curve addition precompile"},ecMul:{v:6e3,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:45e3,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:34e3,d:"Gas costs regarding curve pairing precompile input length"},txDataNonZero:{v:16,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},sstoreSentryGasEIP2200:{v:2300,d:"Minimum gas required to be present for an SSTORE call, not consumed"},sstoreNoopGasEIP2200:{v:800,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:800,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitGasEIP2200:{v:2e4,d:"Once per SSTORE operation from clean zero to non-zero"},sstoreInitRefundEIP2200:{v:19200,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanGasEIP2200:{v:5e3,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreCleanRefundEIP2200:{v:4200,d:"Once per SSTORE operation for resetting to the original non-zero value"},sstoreClearRefundEIP2200:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},balance:{v:700,d:"Base fee of the BALANCE opcode"},extcodehash:{v:700,d:"Base fee of the EXTCODEHASH opcode"},chainid:{v:2,d:"Base fee of the CHAINID opcode"},selfbalance:{v:5,d:"Base fee of the SELFBALANCE opcode"},sload:{v:800,d:"Base fee of the SLOAD opcode"}},Fc={},Oc={},Dc={name:Sc,comment:Ac,url:Hc,status:Cc,gasConfig:Lc,gasPrices:_c,vm:Fc,pow:Oc},Rc="muirGlacier",Gc="HF to delay the difficulty bomb",Mc="https://eips.ethereum.org/EIPS/eip-2384",Nc="Final",qc={},zc={},Uc={},jc={difficultyBombDelay:{v:9e6,d:"the amount of blocks to delay the difficulty bomb with"}},Kc={name:Rc,comment:Gc,url:Mc,status:Nc,gasConfig:qc,gasPrices:zc,vm:Uc,pow:jc},Vc="berlin",Jc="HF targeted for July 2020 following the Muir Glacier HF",Yc="https://eips.ethereum.org/EIPS/eip-2070",Xc="Final",Wc=[2565,2929,2718,2930],Zc={name:Vc,comment:Jc,url:Yc,status:Xc,eips:Wc},Qc="london",ed="HF targeted for July 2021 following the Berlin fork",td="https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",od="Final",sd=[1559,3198,3529,3541],nd={name:Qc,comment:ed,url:td,status:od,eips:sd},rd="shanghai",ad="Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",id="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",cd="Final",dd=[3651,3855,3860,4895],fd={name:rd,comment:ad,url:id,status:cd,eips:dd},ud="arrowGlacier",md="HF to delay the difficulty bomb",hd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",ld="Final",gd=[4345],pd={},bd={},vd={},$d={},kd={name:ud,comment:md,url:hd,status:ld,eips:gd,gasConfig:pd,gasPrices:bd,vm:vd,pow:$d},Id="grayGlacier",Pd="Delaying the difficulty bomb to Mid September 2022",Ed="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",Td="Draft",yd=[5133],wd={},xd={},Bd={},Sd={},Ad={name:Id,comment:Pd,url:Ed,status:Td,eips:yd,gasConfig:wd,gasPrices:xd,vm:Bd,pow:Sd},Hd="mergeForkIdTransition",Cd="Pre-merge hardfork to fork off non-upgraded clients",Ld="https://eips.ethereum.org/EIPS/eip-3675",_d="Draft",Fd=[],Od={name:Hd,comment:Cd,url:Ld,status:_d,eips:Fd},Dd="merge",Rd="Hardfork to upgrade the consensus mechanism to Proof-of-Stake",Gd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",Md="Final",Nd={type:"pos",algorithm:"casper",casper:{}},qd=[3675,4399],zd={name:Dd,comment:Rd,url:Gd,status:Md,consensus:Nd,eips:qd},Ud="shardingFork",jd="Internal hardfork to test proto-danksharding (do not use in production)",Kd="https://eips.ethereum.org/EIPS/eip-4844",Vd="Experimental",Jd=[4844],Yd={name:Ud,comment:jd,url:Kd,status:Vd,eips:Jd};Object.defineProperty(ue,"__esModule",{value:!0});ue.hardforks=void 0;ue.hardforks={chainstart:$i,homestead:Bi,dao:Di,tangerineWhistle:Ki,spuriousDragon:tc,byzantium:fc,constantinople:$c,petersburg:Bc,istanbul:Dc,muirGlacier:Kc,berlin:Zc,london:nd,shanghai:fd,arrowGlacier:kd,grayGlacier:Ad,mergeForkIdTransition:Od,merge:zd,shardingFork:Yd};var X={};Object.defineProperty(X,"__esModule",{value:!0});X.parseGethGenesis=void 0;const ae=L,x=fe;function Xd(i){return!i||i==="0x0"?"0x0000000000000000":(0,ae.isHexPrefixed)(i)?"0x"+(0,ae.stripHexPrefix)(i).padStart(16,"0"):"0x"+i.padStart(16,"0")}function Wd(i,e=!0){const{name:o,config:t,difficulty:s,mixHash:n,gasLimit:a,coinbase:r,baseFeePerGas:d}=i;let{extraData:m,timestamp:u,nonce:l}=i;const E=Number(u),{chainId:w}=t;if(m===""&&(m="0x"),(0,ae.isHexPrefixed)(u)||(u=(0,ae.intToHex)(parseInt(u))),l.length!==18&&(l=Xd(l)),t.eip155Block!==t.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const T={name:o,chainId:w,networkId:w,genesis:{timestamp:u,gasLimit:parseInt(a),difficulty:parseInt(s),nonce:l,extraData:m,mixHash:n,coinbase:r,baseFeePerGas:d},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:t.clique!==void 0?{type:"poa",algorithm:"clique",clique:{period:t.clique.period??t.clique.blockperiodseconds,epoch:t.clique.epoch??t.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},C={[x.Hardfork.Homestead]:{name:"homesteadBlock"},[x.Hardfork.Dao]:{name:"daoForkBlock"},[x.Hardfork.TangerineWhistle]:{name:"eip150Block"},[x.Hardfork.SpuriousDragon]:{name:"eip155Block"},[x.Hardfork.Byzantium]:{name:"byzantiumBlock"},[x.Hardfork.Constantinople]:{name:"constantinopleBlock"},[x.Hardfork.Petersburg]:{name:"petersburgBlock"},[x.Hardfork.Istanbul]:{name:"istanbulBlock"},[x.Hardfork.MuirGlacier]:{name:"muirGlacierBlock"},[x.Hardfork.Berlin]:{name:"berlinBlock"},[x.Hardfork.London]:{name:"londonBlock"},[x.Hardfork.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:e},[x.Hardfork.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[x.Hardfork.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},_=Object.keys(C).reduce((I,H)=>(I[C[H].name]=H,I),{}),K=Object.keys(t).filter(I=>_[I]!==void 0&&t[I]!==void 0&&t[I]!==null);if(T.hardforks=K.map(I=>({name:_[I],block:C[_[I]].isTimestamp===!0||typeof t[I]!="number"?null:t[I],timestamp:C[_[I]].isTimestamp===!0&&typeof t[I]=="number"?t[I]:void 0})).filter(I=>I.block!==null||I.timestamp!==void 0),T.hardforks.sort(function(I,H){return(I.block??1/0)-(H.block??1/0)}),T.hardforks.sort(function(I,H){return(I.timestamp??E)-(H.timestamp??E)}),t.terminalTotalDifficulty!==void 0){const I={name:x.Hardfork.Merge,ttd:t.terminalTotalDifficulty,block:null},H=T.hardforks.findIndex(le=>{var ee;return((ee=C[le.name])==null?void 0:ee.postMerge)===!0});H!==-1?T.hardforks.splice(H,0,I):T.hardforks.push(I)}const F=T.hardforks.length>0?T.hardforks.slice(-1)[0]:void 0;return T.hardfork=F==null?void 0:F.name,T.hardforks.unshift({name:x.Hardfork.Chainstart,block:0}),T}function Zd(i,e,o){try{if(["config","difficulty","gasLimit","alloc"].some(t=>!(t in i)))throw new Error("Invalid format, expected geth genesis fields missing");return e!==void 0&&(i.name=e),Wd(i,o)}catch(t){throw new Error(`Error parsing parameters file: ${t.message}`)}}X.parseGethGenesis=Zd;Object.defineProperty(ce,"__esModule",{value:!0});ce.Common=void 0;const S=L,Qd=Fe,ef=Re,tf=Ze,of=ft,sf=Pt,nf=_t,rf=Kt,R=de,P=fe,af=ue,cf=X;class A extends ef.EventEmitter{constructor(e){super(),this._eips=[],this._customChains=e.customChains??[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=this._chainParams.defaultHardfork??P.Hardfork.Merge,this.HARDFORK_CHANGES=this.hardforks().map(o=>[o.name,af.hardforks[o.name]]),this._hardfork=this.DEFAULT_HARDFORK,e.hardfork!==void 0&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}static custom(e,o={}){const t=o.baseChain??"mainnet",s={...A._getChainParams(t)};if(s.name="custom-chain",typeof e!="string")return new A({chain:{...s,...e},...o});if(e===P.CustomChain.PolygonMainnet)return A.custom({name:P.CustomChain.PolygonMainnet,chainId:137,networkId:137},o);if(e===P.CustomChain.PolygonMumbai)return A.custom({name:P.CustomChain.PolygonMumbai,chainId:80001,networkId:80001},o);if(e===P.CustomChain.ArbitrumRinkebyTestnet)return A.custom({name:P.CustomChain.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},o);if(e===P.CustomChain.ArbitrumOne)return A.custom({name:P.CustomChain.ArbitrumOne,chainId:42161,networkId:42161},o);if(e===P.CustomChain.xDaiChain)return A.custom({name:P.CustomChain.xDaiChain,chainId:100,networkId:100},o);if(e===P.CustomChain.OptimisticKovan)return A.custom({name:P.CustomChain.OptimisticKovan,chainId:69,networkId:69},{hardfork:P.Hardfork.Berlin,...o});if(e===P.CustomChain.OptimisticEthereum)return A.custom({name:P.CustomChain.OptimisticEthereum,chainId:10,networkId:10},{hardfork:P.Hardfork.Berlin,...o});throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:o,eips:t,genesisHash:s,hardfork:n,mergeForkIdPostMerge:a}){const r=(0,cf.parseGethGenesis)(e,o,a),d=new A({chain:r.name??"custom",customChains:[r],eips:t,hardfork:n??r.hardfork});return s!==void 0&&d.setForkHashes(s),d}static isSupportedChainId(e){return!!this._getInitializedChains().names[e.toString()]}static _getChainParams(e,o){const t=this._getInitializedChains(o);if(typeof e=="number"||typeof e=="bigint"){if(e=e.toString(),t.names[e]){const s=t.names[e];return t[s]}throw new Error(`Chain with ID ${e} not supported`)}if(t[e]!==void 0)return t[e];throw new Error(`Chain with name ${e} not supported`)}setChain(e){if(typeof e=="number"||typeof e=="bigint"||typeof e=="string")this._chainParams=A._getChainParams(e,this._customChains);else if(typeof e=="object"){if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const o=["networkId","genesis","hardforks","bootstrapNodes"];for(const t of o)if(!(t in e))throw new Error(`Missing required chain parameter: ${t}`);this._chainParams=e}else throw new Error("Wrong input format");for(const o of this.hardforks())if(o.block===void 0)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let o=!1;for(const t of this.HARDFORK_CHANGES)t[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),o=!0);if(!o)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,o,t){e=(0,S.toType)(e,S.TypeOutput.BigInt),o=(0,S.toType)(o,S.TypeOutput.BigInt),t=(0,S.toType)(t,S.TypeOutput.Number);const s=this.hardforks().filter(u=>u.block!==null||u.ttd!==null&&u.ttd!==void 0||u.timestamp!==void 0),n=s.findIndex(u=>u.ttd!==null&&u.ttd!==void 0);if(s.slice(n+1).findIndex(u=>u.ttd!==null&&u.ttd!==void 0)>=0)throw Error("More than one merge hardforks found with ttd specified");let r=s.findIndex(u=>u.block!==null&&u.block>e||t!==void 0&&Number(u.timestamp)>t);if(r===-1)r=s.length;else if(r===0)throw Error("Must have at least one hardfork at block 0");if(t===void 0){const u=s.slice(0,r).reverse().findIndex(l=>l.block!==null||l.ttd!==void 0);r=r-u}if(r=r-1,s[r].block===null&&s[r].timestamp===void 0)(o==null||BigInt(s[r].ttd)>o)&&(r-=1);else if(n>=0&&o!==void 0&&o!==null){if(r>=n&&BigInt(s[n].ttd)>o)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(r<n&&BigInt(s[n].ttd)<=o)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const d=r;for(;r<s.length-1&&!(s[r].block!==s[r+1].block||s[r].timestamp!==s[r+1].timestamp);r++);if(t){if(s.slice(0,d).reduce((E,w)=>Math.max(Number(w.timestamp??"0"),E),0)>t)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");if(s.slice(r+1).reduce((E,w)=>Math.min(Number(w.timestamp??t),E),t)<t)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}return s[r].name}setHardforkByBlockNumber(e,o,t){const s=this.getHardforkByBlockNumber(e,o,t);return this.setHardfork(s),s}_getHardfork(e){const o=this.hardforks();for(const t of o)if(t.name===e)return t;return null}setEIPs(e=[]){for(const o of e){if(!(o in R.EIPs))throw new Error(`${o} not supported`);const t=this.gteHardfork(R.EIPs[o].minimumHardfork);if(!t)throw new Error(`${o} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${t}`);if(R.EIPs[o].requiredEIPs!==void 0){for(const s of R.EIPs[o].requiredEIPs)if(!(e.includes(s)||this.isActivatedEIP(s)))throw new Error(`${o} requires EIP ${s}, but is not included in the EIP list`)}}this._eips=e}param(e,o){let t;for(const s of this._eips)if(t=this.paramByEIP(e,o,s),t!==void 0)return t;return this.paramByHardfork(e,o,this._hardfork)}paramByHardfork(e,o,t){let s=null;for(const n of this.HARDFORK_CHANGES){if("eips"in n[1]){const a=n[1].eips;for(const r of a){const d=this.paramByEIP(e,o,r);s=typeof d=="bigint"?d:s}}else{if(n[1][e]===void 0)throw new Error(`Topic ${e} not defined`);n[1][e][o]!==void 0&&(s=n[1][e][o].v)}if(n[0]===t)break}return BigInt(s??0)}paramByEIP(e,o,t){if(!(t in R.EIPs))throw new Error(`${t} not supported`);const s=R.EIPs[t];if(!(e in s))throw new Error(`Topic ${e} not defined`);if(s[e][o]===void 0)return;const n=s[e][o].v;return BigInt(n)}paramByBlock(e,o,t,s,n){const a=this.getHardforkByBlockNumber(t,s,n);return this.paramByHardfork(e,o,a)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const o of this.HARDFORK_CHANGES){const t=o[1];if(this.gteHardfork(t.name)&&"eips"in t&&t.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,o){o=(0,S.toType)(o,S.TypeOutput.BigInt),e=e??this._hardfork;const t=this.hardforkBlock(e);return typeof t=="bigint"&&t!==BigInt(0)&&o>=t}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,o){e=e??this._hardfork;const t=this.hardforks();let s=-1,n=-1,a=0;for(const r of t)r.name===e&&(s=a),r.name===o&&(n=a),a+=1;return s>=n&&n!==-1}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.block;return o==null?null:BigInt(o)}hardforkTimestamp(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.timestamp;return o==null?null:BigInt(o)}eipBlock(e){for(const o of this.HARDFORK_CHANGES){const t=o[1];if("eips"in t&&t.eips.includes(e))return this.hardforkBlock(o[0])}return null}hardforkTTD(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.ttd;return o==null?null:BigInt(o)}isHardforkBlock(e,o){e=(0,S.toType)(e,S.TypeOutput.BigInt),o=o??this._hardfork;const t=this.hardforkBlock(o);return typeof t=="bigint"&&t!==BigInt(0)?t===e:!1}nextHardforkBlockOrTimestamp(e){e=e??this._hardfork;const o=this.hardforks();let t=o.findIndex(r=>r.name===e);if(e===P.Hardfork.Merge&&(t-=1),t<0)return null;let s=o[t].timestamp??o[t].block;s=s!=null?Number(s):null;const n=o.slice(t+1).find(r=>{let d=r.timestamp??r.block;return d=d!=null?Number(d):null,r.name!==P.Hardfork.Merge&&d!==null&&d!==void 0&&d!==s});if(n===void 0)return null;const a=n.timestamp??n.block;return a==null?null:BigInt(a)}nextHardforkBlock(e){e=e??this._hardfork;let o=this.hardforkBlock(e);if(o===null&&e===P.Hardfork.Merge){const s=this.hardforks(),n=s.findIndex(a=>a.ttd!==null&&a.ttd!==void 0);if(n<0)throw Error("Merge hardfork should have been found");o=this.hardforkBlock(s[n-1].name)}return o===null?null:this.hardforks().reduce((s,n)=>{const a=BigInt(n.block===null||n.ttd!==void 0&&n.ttd!==null?0:n.block);return a>o&&s===null?a:s},null)}isNextHardforkBlock(e,o){e=(0,S.toType)(e,S.TypeOutput.BigInt),o=o??this._hardfork;const t=this.nextHardforkBlock(o);return t===null?!1:t===e}_calcForkHash(e,o){let t=h.alloc(0),s=0;for(const r of this.hardforks()){const{block:d,timestamp:m,name:u}=r;let l=m??d;if(l=l!==null?Number(l):null,typeof l=="number"&&l!==0&&l!==s&&u!==P.Hardfork.Merge){const E=h.from(l.toString(16).padStart(16,"0"),"hex");t=h.concat([t,E]),s=l}if(r.name===e)break}const n=h.concat([o,t]);return`0x${(0,S.intToBuffer)((0,Qd.buf)(n)>>>0).toString("hex")}`}forkHash(e,o){e=e??this._hardfork;const t=this._getHardfork(e);if(t===null||(t==null?void 0:t.block)===null&&(t==null?void 0:t.timestamp)===void 0&&(t==null?void 0:t.ttd)===void 0){const s="No fork hash calculation possible for future hardfork";throw new Error(s)}if((t==null?void 0:t.forkHash)!==null&&(t==null?void 0:t.forkHash)!==void 0)return t.forkHash;if(!o)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(e,o)}hardforkForForkHash(e){const o=this.hardforks().filter(t=>t.forkHash===e);return o.length>=1?o[o.length-1]:null}setForkHashes(e){for(const o of this.hardforks()){const t=o.timestamp??o.block;(o.forkHash===null||o.forkHash===void 0)&&(t!=null||typeof o.ttd<"u")&&(o.forkHash=this.forkHash(o.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus.type),t[0]===e)break;return o??this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus.algorithm),t[0]===e)break;return o??this._chainParams.consensus.algorithm}consensusConfig(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus[t[1].consensus.algorithm]),t[0]===e)break;return o??this._chainParams.consensus[this.consensusAlgorithm()]??{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const o={};for(const[s,n]of Object.entries(P.Chain))o[n]=s.toLowerCase();const t={mainnet:of,ropsten:nf,rinkeby:sf,goerli:tf,sepolia:rf};if(e)for(const s of e){const{name:n}=s;o[s.chainId.toString()]=n,t[n]=s}return t.names=o,t}}ce.Common=A;var Oe={};Object.defineProperty(Oe,"__esModule",{value:!0});(function(i){var e=O&&O.__createBinding||(Object.create?function(t,s,n,a){a===void 0&&(a=n);var r=Object.getOwnPropertyDescriptor(s,n);(!r||("get"in r?!s.__esModule:r.writable||r.configurable))&&(r={enumerable:!0,get:function(){return s[n]}}),Object.defineProperty(t,a,r)}:function(t,s,n,a){a===void 0&&(a=n),t[a]=s[n]}),o=O&&O.__exportStar||function(t,s){for(var n in t)n!=="default"&&!Object.prototype.hasOwnProperty.call(s,n)&&e(s,t,n)};Object.defineProperty(i,"__esModule",{value:!0}),o(ce,i),o(fe,i),o(Oe,i),o(X,i)})(_e);var W={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.isAccessList=i.isAccessListBuffer=i.Capability=void 0,function(t){t[t.EIP155ReplayProtection=155]="EIP155ReplayProtection",t[t.EIP1559FeeMarket=1559]="EIP1559FeeMarket",t[t.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",t[t.EIP2930AccessLists=2930]="EIP2930AccessLists"}(i.Capability||(i.Capability={}));function e(t){if(t.length===0)return!0;const s=t[0];return!!Array.isArray(s)}i.isAccessListBuffer=e;function o(t){return!e(t)}i.isAccessList=o})(W);var D={};Object.defineProperty(D,"__esModule",{value:!0});D.AccessLists=D.checkMaxInitCodeSize=void 0;const G=L,df=W;function ff(i,e){const o=i.param("vm","maxInitCodeSize");if(o&&BigInt(e)>o)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${i.param("vm","maxInitCodeSize")}`)}D.checkMaxInitCodeSize=ff;class uf{static getAccessListData(e){let o,t;if((0,df.isAccessList)(e)){o=e;const s=[];for(let n=0;n<e.length;n++){const a=e[n],r=(0,G.toBuffer)(a.address),d=[];for(let m=0;m<a.storageKeys.length;m++)d.push((0,G.toBuffer)(a.storageKeys[m]));s.push([r,d])}t=s}else{t=e??[];const s=[];for(let n=0;n<t.length;n++){const a=t[n],r=(0,G.bufferToHex)(a[0]),d=[];for(let u=0;u<a[1].length;u++)d.push((0,G.bufferToHex)(a[1][u]));const m={address:r,storageKeys:d};s.push(m)}o=s}return{AccessListJSON:o,accessList:t}}static verifyAccessList(e){for(let o=0;o<e.length;o++){const t=e[o],s=t[0],n=t[1];if(t[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(s.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let a=0;a<n.length;a++)if(n[a].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const o=[];for(let t=0;t<e.length;t++){const s=e[t],n={address:"0x"+(0,G.setLengthLeft)(s[0],20).toString("hex"),storageKeys:[]},a=s[1];for(let r=0;r<a.length;r++){const d=a[r];n.storageKeys.push("0x"+(0,G.setLengthLeft)(d,32).toString("hex"))}o.push(n)}return o}static getDataFeeEIP2930(e,o){const t=o.param("gasPrices","accessListStorageKeyCost"),s=o.param("gasPrices","accessListAddressCost");let n=0;for(let r=0;r<e.length;r++){const m=e[r][1];n+=m.length}return e.length*Number(s)+n*Number(t)}}D.AccessLists=uf;Object.defineProperty(j,"__esModule",{value:!0});j.BaseTransaction=void 0;const M=_e,$=L,pe=W,mf=D;class hf{constructor(e,o){this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=M.Chain.Mainnet,this.DEFAULT_HARDFORK=M.Hardfork.Merge;const{nonce:t,gasLimit:s,to:n,value:a,data:r,v:d,r:m,s:u,type:l}=e;this._type=Number((0,$.bufferToBigInt)((0,$.toBuffer)(l))),this.txOptions=o;const E=(0,$.toBuffer)(n===""?"0x":n),w=(0,$.toBuffer)(d===""?"0x":d),T=(0,$.toBuffer)(m===""?"0x":m),C=(0,$.toBuffer)(u===""?"0x":u);this.nonce=(0,$.bufferToBigInt)((0,$.toBuffer)(t===""?"0x":t)),this.gasLimit=(0,$.bufferToBigInt)((0,$.toBuffer)(s===""?"0x":s)),this.to=E.length>0?new $.Address(E):void 0,this.value=(0,$.bufferToBigInt)((0,$.toBuffer)(a===""?"0x":a)),this.data=(0,$.toBuffer)(r===""?"0x":r),this.v=w.length>0?(0,$.bufferToBigInt)(w):void 0,this.r=T.length>0?(0,$.bufferToBigInt)(T):void 0,this.s=C.length>0?(0,$.bufferToBigInt)(C):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const _=this.to===void 0||this.to===null,K=o.allowUnlimitedInitCodeSize??!1,F=o.common??this._getCommon();_&&F.isActivatedEIP(3860)&&K===!1&&(0,mf.checkMaxInitCodeSize)(F,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const o=[];return this.getBaseFee()>this.gasLimit&&o.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&o.push("Invalid Signature"),e?o:o.length===0}_validateYParity(){const{v:e}=this;if(e!==void 0&&e!==BigInt(0)&&e!==BigInt(1)){const o=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(o)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&e!==void 0&&e>$.SECP256K1_ORDER_DIV_2){const o=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(o)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let o=this.getDataFee();if(e&&(o+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const t=this.common.param("gasPrices","txCreation");t&&(o+=t)}return o}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),o=this.common.param("gasPrices","txDataNonZero");let t=BigInt(0);for(let s=0;s<this.data.length;s++)this.data[s]===0?t+=e:t+=o;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const s=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*s;t+=n}return t}toCreationAddress(){return this.to===void 0||this.to.buf.length===0}isSigned(){const{v:e,r:o,s:t}=this;return!(e===void 0||o===void 0||t===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return(0,$.unpadBuffer)(e).length!==0}catch{return!1}}getSenderAddress(){return new $.Address((0,$.publicToAddress)(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const d=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(d)}let o=!1;this.type===0&&this.common.gteHardfork("spuriousDragon")&&!this.supports(pe.Capability.EIP155ReplayProtection)&&(this.activeCapabilities.push(pe.Capability.EIP155ReplayProtection),o=!0);const t=this.getMessageToSign(!0),{v:s,r:n,s:a}=(0,$.ecsign)(t,e),r=this._processSignature(s,n,a);if(o){const d=this.activeCapabilities.indexOf(pe.Capability.EIP155ReplayProtection);d>-1&&this.activeCapabilities.splice(d,1)}return r}_getCommon(e,o){if(o!==void 0){const t=(0,$.bufferToBigInt)((0,$.toBuffer)(o));if(e){if(e.chainId()!==t){const s=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(s)}return e.copy()}else return M.Common.isSupportedChainId(t)?new M.Common({chain:t,hardfork:this.DEFAULT_HARDFORK}):M.Common.custom({name:"custom-chain",networkId:t,chainId:t},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}else return(e==null?void 0:e.copy())??new M.Common({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,o=256,t=!1){for(const[s,n]of Object.entries(e))switch(o){case 64:if(t){if(n!==void 0&&n>=$.MAX_UINT64){const a=this._errorMsg(`${s} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>$.MAX_UINT64){const a=this._errorMsg(`${s} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}break;case 256:if(t){if(n!==void 0&&n>=$.MAX_INTEGER){const a=this._errorMsg(`${s} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>$.MAX_INTEGER){const a=this._errorMsg(`${s} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}break;default:{const a=this._errorMsg("unimplemented bits value");throw new Error(a)}}}static _validateNotArray(e){const o=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[t,s]of Object.entries(e))if(o.includes(t)&&Array.isArray(s))throw new Error(`${t} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?(0,$.bufferToHex)(this.hash()):"not available (unsigned)"}catch{e="error"}let o="";try{o=this.isSigned().toString()}catch{e="error"}let t="";try{t=this.common.hardfork()}catch{t="error"}let s=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return s+=`signed=${o} hf=${t}`,s}}j.BaseTransaction=hf;Object.defineProperty(Y,"__esModule",{value:!0});Y.FeeMarketEIP1559Transaction=void 0;const be=ye,p=L,ve=we,Be=j,te=D,Ee=2,$e=h.from(Ee.toString(16).padStart(2,"0"),"hex");class z extends Be.BaseTransaction{constructor(e,o={}){super({...e,type:Ee},o),this.DEFAULT_HARDFORK="london";const{chainId:t,accessList:s,maxFeePerGas:n,maxPriorityFeePerGas:a}=e;if(this.common=this._getCommon(o.common,t),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const r=te.AccessLists.getAccessListData(s??[]);if(this.accessList=r.accessList,this.AccessListJSON=r.AccessListJSON,te.AccessLists.verifyAccessList(this.accessList),this.maxFeePerGas=(0,p.bufferToBigInt)((0,p.toBuffer)(n===""?"0x":n)),this.maxPriorityFeePerGas=(0,p.bufferToBigInt)((0,p.toBuffer)(a===""?"0x":a)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),Be.BaseTransaction._validateNotArray(e),this.gasLimit*this.maxFeePerGas>p.MAX_INTEGER){const m=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(m)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const m=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(m)}this._validateYParity(),this._validateHighS(),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new z(e,o)}static fromSerializedTx(e,o={}){if(!e.slice(0,1).equals($e))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${Ee}, received: ${e.slice(0,1).toString("hex")}`);const t=(0,p.arrToBufArr)(be.RLP.decode(e.slice(1)));if(!Array.isArray(t))throw new Error("Invalid serialized tx input: must be array");return z.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[t,s,n,a,r,d,m,u,l,E,w,T]=e;return this._validateNotArray({chainId:t,v:E}),(0,p.validateNoLeadingZeroes)({nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,value:m,v:E,r:w,s:T}),new z({chainId:(0,p.bufferToBigInt)(t),nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,to:d,value:m,data:u,accessList:l??[],v:E!==void 0?(0,p.bufferToBigInt)(E):void 0,r:w,s:T},o)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(te.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const o=this.maxPriorityFeePerGas,t=this.maxFeePerGas-e,n=(o<t?o:t)+e;return this.gasLimit*n+this.value}raw(){return[(0,p.bigIntToUnpaddedBuffer)(this.chainId),(0,p.bigIntToUnpaddedBuffer)(this.nonce),(0,p.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),(0,p.bigIntToUnpaddedBuffer)(this.maxFeePerGas),(0,p.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:h.from([]),(0,p.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.v):h.from([]),this.r!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.r):h.from([]),this.s!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.s):h.from([])]}serialize(){const e=this.raw();return h.concat([$e,h.from(be.RLP.encode((0,p.bufArrToArr)(e)))])}getMessageToSign(e=!0){const o=this.raw().slice(0,9),t=h.concat([$e,h.from(be.RLP.encode((0,p.bufArrToArr)(o)))]);return e?h.from((0,ve.keccak256)(t)):t}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=h.from((0,ve.keccak256)(this.serialize()))),this.cache.hash):h.from((0,ve.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,p.ecrecover)(e,o+BigInt(27),(0,p.bigIntToUnpaddedBuffer)(t),(0,p.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){const s={...this.txOptions,common:this.common};return z.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,p.bufferToBigInt)(o),s:(0,p.bufferToBigInt)(t)},s)}toJSON(){const e=te.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,p.bigIntToHex)(this.chainId),nonce:(0,p.bigIntToHex)(this.nonce),maxPriorityFeePerGas:(0,p.bigIntToHex)(this.maxPriorityFeePerGas),maxFeePerGas:(0,p.bigIntToHex)(this.maxFeePerGas),gasLimit:(0,p.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,p.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,p.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,p.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,p.bigIntToHex)(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}Y.FeeMarketEIP1559Transaction=z;var Z={};Object.defineProperty(Z,"__esModule",{value:!0});Z.AccessListEIP2930Transaction=void 0;const ke=ye,b=L,Ie=we,Se=j,oe=D,Te=1,Pe=h.from(Te.toString(16).padStart(2,"0"),"hex");class U extends Se.BaseTransaction{constructor(e,o={}){super({...e,type:Te},o),this.DEFAULT_HARDFORK="berlin";const{chainId:t,accessList:s,gasPrice:n}=e;if(this.common=this._getCommon(o.common,t),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const a=oe.AccessLists.getAccessListData(s??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,oe.AccessLists.verifyAccessList(this.accessList),this.gasPrice=(0,b.bufferToBigInt)((0,b.toBuffer)(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Se.BaseTransaction._validateNotArray(e),this.gasPrice*this.gasLimit>b.MAX_INTEGER){const d=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(d)}this._validateYParity(),this._validateHighS(),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new U(e,o)}static fromSerializedTx(e,o={}){if(!e.slice(0,1).equals(Pe))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${Te}, received: ${e.slice(0,1).toString("hex")}`);const t=(0,b.arrToBufArr)(ke.RLP.decode(Uint8Array.from(e.slice(1))));if(!Array.isArray(t))throw new Error("Invalid serialized tx input: must be array");return U.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[t,s,n,a,r,d,m,u,l,E,w]=e;this._validateNotArray({chainId:t,v:l}),(0,b.validateNoLeadingZeroes)({nonce:s,gasPrice:n,gasLimit:a,value:d,v:l,r:E,s:w});const T=[];return new U({chainId:(0,b.bufferToBigInt)(t),nonce:s,gasPrice:n,gasLimit:a,to:r,value:d,data:m,accessList:u??T,v:l!==void 0?(0,b.bufferToBigInt)(l):void 0,r:E,s:w},o)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(oe.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[(0,b.bigIntToUnpaddedBuffer)(this.chainId),(0,b.bigIntToUnpaddedBuffer)(this.nonce),(0,b.bigIntToUnpaddedBuffer)(this.gasPrice),(0,b.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:h.from([]),(0,b.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,b.bigIntToUnpaddedBuffer)(this.v):h.from([]),this.r!==void 0?(0,b.bigIntToUnpaddedBuffer)(this.r):h.from([]),this.s!==void 0?(0,b.bigIntToUnpaddedBuffer)(this.s):h.from([])]}serialize(){const e=this.raw();return h.concat([Pe,h.from(ke.RLP.encode((0,b.bufArrToArr)(e)))])}getMessageToSign(e=!0){const o=this.raw().slice(0,8),t=h.concat([Pe,h.from(ke.RLP.encode((0,b.bufArrToArr)(o)))]);return e?h.from((0,Ie.keccak256)(t)):t}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=h.from((0,Ie.keccak256)(this.serialize()))),this.cache.hash):h.from((0,Ie.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,b.ecrecover)(e,o+BigInt(27),(0,b.bigIntToUnpaddedBuffer)(t),(0,b.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){const s={...this.txOptions,common:this.common};return U.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,b.bufferToBigInt)(o),s:(0,b.bufferToBigInt)(t)},s)}toJSON(){const e=oe.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,b.bigIntToHex)(this.chainId),nonce:(0,b.bigIntToHex)(this.nonce),gasPrice:(0,b.bigIntToHex)(this.gasPrice),gasLimit:(0,b.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,b.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,b.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,b.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,b.bigIntToHex)(this.s):void 0}}errorStr(){var o;let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${((o=this.accessList)==null?void 0:o.length)??0}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}Z.AccessListEIP2930Transaction=U;var Q={};Object.defineProperty(Q,"__esModule",{value:!0});Q.Transaction=void 0;const N=ye,g=L,se=we,Ae=j,V=W,lf=0;function He(i,e){const o=Number(i),t=Number(e)*2;return o===t+35||o===t+36}class J extends Ae.BaseTransaction{constructor(e,o={}){if(super({...e,type:lf},o),this.common=this._validateTxV(this.v,o.common),this.gasPrice=(0,g.bufferToBigInt)((0,g.toBuffer)(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>g.MAX_INTEGER){const s=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(s)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Ae.BaseTransaction._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?He(this.v,this.common.chainId())&&this.activeCapabilities.push(V.Capability.EIP155ReplayProtection):this.activeCapabilities.push(V.Capability.EIP155ReplayProtection)),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new J(e,o)}static fromSerializedTx(e,o={}){const t=(0,g.arrToBufArr)(N.RLP.decode(Uint8Array.from(e)));if(!Array.isArray(t))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[t,s,n,a,r,d,m,u,l]=e;return(0,g.validateNoLeadingZeroes)({nonce:t,gasPrice:s,gasLimit:n,value:r,v:m,r:u,s:l}),new J({nonce:t,gasPrice:s,gasLimit:n,to:a,value:r,data:d,v:m,r:u,s:l},o)}raw(){return[(0,g.bigIntToUnpaddedBuffer)(this.nonce),(0,g.bigIntToUnpaddedBuffer)(this.gasPrice),(0,g.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:h.from([]),(0,g.bigIntToUnpaddedBuffer)(this.value),this.data,this.v!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.v):h.from([]),this.r!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.r):h.from([]),this.s!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.s):h.from([])]}serialize(){return h.from(N.RLP.encode((0,g.bufArrToArr)(this.raw())))}_getMessageToSign(){const e=[(0,g.bigIntToUnpaddedBuffer)(this.nonce),(0,g.bigIntToUnpaddedBuffer)(this.gasPrice),(0,g.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:h.from([]),(0,g.bigIntToUnpaddedBuffer)(this.value),this.data];return this.supports(V.Capability.EIP155ReplayProtection)&&(e.push((0,g.bigIntToUnpaddedBuffer)(this.common.chainId())),e.push((0,g.unpadBuffer)((0,g.toBuffer)(0))),e.push((0,g.unpadBuffer)((0,g.toBuffer)(0)))),e}getMessageToSign(e=!0){const o=this._getMessageToSign();return e?h.from((0,se.keccak256)(N.RLP.encode((0,g.bufArrToArr)(o)))):o}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=h.from((0,se.keccak256)(N.RLP.encode((0,g.bufArrToArr)(this.raw()))))),this.cache.hash):h.from((0,se.keccak256)(N.RLP.encode((0,g.bufArrToArr)(this.raw()))))}getMessageToVerifySignature(){if(!this.isSigned()){const o=this._errorMsg("This transaction is not signed");throw new Error(o)}const e=this._getMessageToSign();return h.from((0,se.keccak256)(N.RLP.encode((0,g.bufArrToArr)(e))))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,g.ecrecover)(e,o,(0,g.bigIntToUnpaddedBuffer)(t),(0,g.bigIntToUnpaddedBuffer)(s),this.supports(V.Capability.EIP155ReplayProtection)?this.common.chainId():void 0)}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){this.supports(V.Capability.EIP155ReplayProtection)&&(e+=this.common.chainId()*BigInt(2)+BigInt(8));const s={...this.txOptions,common:this.common};return J.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:(0,g.bufferToBigInt)(o),s:(0,g.bufferToBigInt)(t)},s)}toJSON(){return{nonce:(0,g.bigIntToHex)(this.nonce),gasPrice:(0,g.bigIntToHex)(this.gasPrice),gasLimit:(0,g.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,g.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),v:this.v!==void 0?(0,g.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,g.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,g.bigIntToHex)(this.s):void 0}}_validateTxV(e,o){let t;const s=e!==void 0?Number(e):void 0;if(s!==void 0&&s<37&&s!==27&&s!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${s}`);if(s!==void 0&&s!==0&&(!o||o.gteHardfork("spuriousDragon"))&&s!==27&&s!==28)if(o){if(!He(BigInt(s),o.chainId()))throw new Error(`Incompatible EIP155-based V ${s} and chain id ${o.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(s-35)%2===0?n=35:n=36,t=BigInt(s-n)/BigInt(2)}return this._getCommon(o,t)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}Q.Transaction=J;var me={},he={};Object.defineProperty(he,"__esModule",{value:!0});he.normalizeTxParams=void 0;const q=L,gf=i=>{const e=Object.assign({},i);return e.gasLimit=(0,q.toType)(e.gasLimit??e.gas,q.TypeOutput.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?(0,q.setLengthLeft)((0,q.toBuffer)(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,e.v!=="0x"&&(e.v=(0,q.toType)(e.v,q.TypeOutput.BigInt)),e};he.normalizeTxParams=gf;Object.defineProperty(me,"__esModule",{value:!0});me.TransactionFactory=void 0;const ne=L,Ce=Y,Le=Z,pf=he,re=Q;class ie{constructor(){}static fromTxData(e,o={}){if(!("type"in e)||e.type===void 0)return re.Transaction.fromTxData(e,o);{const t=Number((0,ne.bufferToBigInt)((0,ne.toBuffer)(e.type)));if(t===0)return re.Transaction.fromTxData(e,o);if(t===1)return Le.AccessListEIP2930Transaction.fromTxData(e,o);if(t===2)return Ce.FeeMarketEIP1559Transaction.fromTxData(e,o);throw new Error(`Tx instantiation with type ${t} not supported`)}}static fromSerializedData(e,o={}){if(e[0]<=127)switch(e[0]){case 1:return Le.AccessListEIP2930Transaction.fromSerializedTx(e,o);case 2:return Ce.FeeMarketEIP1559Transaction.fromSerializedTx(e,o);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return re.Transaction.fromSerializedTx(e,o)}static fromBlockBodyData(e,o={}){if(h.isBuffer(e))return this.fromSerializedData(e,o);if(Array.isArray(e))return re.Transaction.fromValuesArray(e,o);throw new Error("Cannot decode transaction: unknown type input")}static async fromEthersProvider(e,o,t){const s=(0,ne.getProvider)(e),n=await(0,ne.fetchFromProvider)(s,{method:"eth_getTransactionByHash",params:[o]});if(n===null)throw new Error("No data returned from provider");return ie.fromRPCTx(n,t)}static async fromRPCTx(e,o={}){return ie.fromTxData((0,pf.normalizeTxParams)(e),o)}}me.TransactionFactory=ie;(function(i){var e=O&&O.__createBinding||(Object.create?function(r,d,m,u){u===void 0&&(u=m);var l=Object.getOwnPropertyDescriptor(d,m);(!l||("get"in l?!d.__esModule:l.writable||l.configurable))&&(l={enumerable:!0,get:function(){return d[m]}}),Object.defineProperty(r,u,l)}:function(r,d,m,u){u===void 0&&(u=m),r[u]=d[m]}),o=O&&O.__exportStar||function(r,d){for(var m in r)m!=="default"&&!Object.prototype.hasOwnProperty.call(d,m)&&e(d,r,m)};Object.defineProperty(i,"__esModule",{value:!0}),i.TransactionFactory=i.Transaction=i.AccessListEIP2930Transaction=i.FeeMarketEIP1559Transaction=void 0;var t=Y;Object.defineProperty(i,"FeeMarketEIP1559Transaction",{enumerable:!0,get:function(){return t.FeeMarketEIP1559Transaction}});var s=Z;Object.defineProperty(i,"AccessListEIP2930Transaction",{enumerable:!0,get:function(){return s.AccessListEIP2930Transaction}});var n=Q;Object.defineProperty(i,"Transaction",{enumerable:!0,get:function(){return n.Transaction}});var a=me;Object.defineProperty(i,"TransactionFactory",{enumerable:!0,get:function(){return a.TransactionFactory}}),o(W,i)})(xe);const bf=Ge(xe),$f=Me({__proto__:null,default:bf},[xe]);export{_e as a,xe as d,$f as i};
